{"version":3,"file":"magic-wand.js","sources":["../src/MagicWand.js"],"sourcesContent":["ï»¿/*\n Magic wand tool (fuzzy selection) by color\n\n @package magic-wand-tool\n @author Ryasnoy Paul <ryasnoypaul@gmail.com>\n @version 1.1.4\n @license MIT\n @copyright (c) 2014-2019, Ryasnoy Paul <ryasnoypaul@gmail.com>\n\n*/\n\nMagicWand = (function () {\n  var lib = {};\n\n  /** Create a binary mask on the image by color threshold\n    * Algorithm: Scanline flood fill (http://en.wikipedia.org/wiki/Flood_fill)\n    * @param {Object} image: {Uint8Array} data, {int} width, {int} height, {int} bytes\n    * @param {int} x of start pixel\n    * @param {int} y of start pixel\n    * @param {int} color threshold\n    * @param {Uint8Array} mask of visited points (optional)\n    * @param {boolean} [includeBorders=false] indicate whether to include borders pixels\n    * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    */\n  lib.floodFill = function(image, px, py, extraX, extraY, colorThreshold, mask, includeBorders, radius = 20) {\n      return includeBorders\n          ? floodFillWithBorders(image, px, py, extraX, extraY, colorThreshold, mask, radius)\n          : floodFillWithoutBorders(image, px, py, colorThreshold, mask);\n  };\n\n  function floodFillWithoutBorders(image, px, py, colorThreshold, mask) {\n\n      var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\n          data = image.data,\n          w = image.width,\n          h = image.height,\n          bytes = image.bytes, // number of bytes in the color\n          maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\n          i = py * w + px, // start point index in the mask data\n          result = new Uint8Array(w * h), // result mask\n          visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\n\n      if (visited[i] === 1) return null;\n\n      i = i * bytes; // start point index in the image data\n      var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\n\n      var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\n      do {\n          el = stack.shift(); // get line for scanning\n\n          checkY = false;\n          for (x = el.left + 1; x < el.right; x++) {\n              dy = el.y * w;\n              i = (dy + x) * bytes; // point index in the image data\n\n              if (visited[dy + x] === 1) continue; // check whether the point has been visited\n              // compare the color of the sample\n              c = data[i] - sampleColor[0]; // check by red\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 1] - sampleColor[1]; // check by green\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 2] - sampleColor[2]; // check by blue\n              if (c > colorThreshold || c < -colorThreshold) continue;\n\n              checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y\n\n              result[dy + x] = 1; // mark a new point in mask\n              visited[dy + x] = 1; // mark a new point as visited\n\n              xl = x - 1;\n              // walk to left side starting with the left neighbor\n              while (xl > -1) {\n                  dyl = dy + xl;\n                  i = dyl * bytes; // point index in the image data\n                  if (visited[dyl] === 1) break; // check whether the point has been visited\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n\n                  result[dyl] = 1;\n                  visited[dyl] = 1;\n\n                  xl--;\n              }\n              xr = x + 1;\n              // walk to right side starting with the right neighbor\n              while (xr < w) {\n                  dyr = dy + xr;\n                  i = dyr * bytes; // index point in the image data\n                  if (visited[dyr] === 1) break; // check whether the point has been visited\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n\n                  result[dyr] = 1;\n                  visited[dyr] = 1;\n\n                  xr++;\n              }\n\n              // check minmax for X\n              if (xl < minX) minX = xl + 1;\n              if (xr > maxX) maxX = xr - 1;\n\n              newY = el.y - el.dir;\n              if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\n                  if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\n                  if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\n              }\n              newY = el.y + el.dir;\n              if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\n                  if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\n              }\n          }\n          // check minmax for Y if necessary\n          if (checkY) {\n              if (el.y < minY) minY = el.y;\n              if (el.y > maxY) maxY = el.y;\n          }\n      } while (stack.length > 0);\n\n      return {\n          data: result,\n          width: image.width,\n          height: image.height,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  }\n  function distance(x1, y1, x2, y2) {\n      var dx = Math.abs(x1 - x2);\n      var dy = Math.abs(y1 - y2);\n      return Math.sqrt(dx * dx + dy * dy);\n  }\n  function floodFillWithBorders(image, px, py, extraX, extraY, colorThreshold, mask, radius) {\n      console.log('floodFillWithBordersssssssss', px, py, colorThreshold);\n      var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\n          data = image.data,\n          w = image.width,\n          h = image.height,\n          bytes = image.bytes, // number of bytes in the color\n          maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\n          i = py * w + px, // start point index in the mask data\n          result = new Uint8Array(mask ? mask : w * h), // result mask\n          visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\n\n      // console.log('iiiiiiiiiiiiiiii', i);\n      // console.log('iiiii22222222222', result);\n      // console.log('iiiii33333333333', visited);\n      let allVisited = true;\n      if (extraX !== null && extraY !== null) {\n          console.log('extraaaaaaaaaa', extraX, extraY);\n          for (var dpx = -radius; dpx <= radius; dpx++) {\n              for (var dpy = -radius; dpy <= radius; dpy++) {\n                  // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n                  if (extraY + dpy < 0 || extraY + dpy >= h || extraX + dpx < 0 || extraX + dpx >= w) continue;\n                  if (distance(extraX, extraY, extraX + dpx, extraY + dpy) > radius) continue;\n                  var k = (extraY + dpy) * w + extraX + dpx;\n                  if (visited[k] === 0) {\n                      // visited[k] = 1;\n                      result[k] = 1;\n                      allVisited = false;\n                  }\n              }\n          }\n      } else {\n          for (var dpx = -radius; dpx <= radius; dpx++) {\n              for (var dpy = -radius; dpy <= radius; dpy++) {\n                  if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n                  if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n                  var k = (py + dpy) * w + px + dpx;\n                  if (visited[k] === 0) {\n                      allVisited = false;\n                      break;\n                  }\n              }\n              if (!allVisited) break;\n          }\n      }\n      if (allVisited) {\n          return null;\n      }\n\n      i = i * bytes; // start point index in the image data\n      var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\n\n      // var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\n      var stack = [];\n      for (var dpx = -radius; dpx <= radius; dpx++) {\n          for (var dpy = -radius; dpy <= radius; dpy++) {\n              // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n              if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n              if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n              stack.push({ y: py + dpy, left: px + dpx - 1, right: px + dpx + 1, dir: 1 });\n          }\n      }\n      console.log('stackkkkkk', stack.length);\n      do {\n          el = stack.shift(); // get line for scanning\n\n          checkY = false;\n          for (x = el.left + 1; x < el.right; x++) {\n              dy = el.y * w;\n              i = (dy + x) * bytes; // point index in the image data\n\n              if (visited[dy + x] === 1) continue; // check whether the point has been visited\n\n              checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y\n\n              result[dy + x] = 1; // mark a new point in mask\n              visited[dy + x] = 1; // mark a new point as visited\n\n              // console.log('3333333333333', data[i + 3]);\n              if (data[i + 3] === 0) {\n                  continue;\n              }\n              // compare the color of the sample\n              c = data[i] - sampleColor[0]; // check by red\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 1] - sampleColor[1]; // check by green\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 2] - sampleColor[2]; // check by blue\n              if (c > colorThreshold || c < -colorThreshold) continue;\n\n              xl = x - 1;\n              // walk to left side starting with the left neighbor\n              while (xl > -1) {\n                  dyl = dy + xl;\n                  i = dyl * bytes; // point index in the image data\n                  if (visited[dyl] === 1) break; // check whether the point has been visited\n\n                  result[dyl] = 1;\n                  visited[dyl] = 1;\n                  xl--;\n\n                  if (data[i + 3] === 0) {\n                      break;\n                  }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n              xr = x + 1;\n              // walk to right side starting with the right neighbor\n              while (xr < w) {\n                  dyr = dy + xr;\n                  i = dyr * bytes; // index point in the image data\n                  if (visited[dyr] === 1) break; // check whether the point has been visited\n\n                  result[dyr] = 1;\n                  visited[dyr] = 1;\n                  xr++;\n\n                  if (data[i + 3] === 0) {\n                      break;\n                  }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n\n              // check minmax for X\n              if (xl < minX) minX = xl + 1;\n              if (xr > maxX) maxX = xr - 1;\n\n              newY = el.y - el.dir;\n              if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\n                  if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\n                  if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\n              }\n              newY = el.y + el.dir;\n              if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\n                  if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\n              }\n          }\n          // check minmax for Y if necessary\n          if (checkY) {\n              if (el.y < minY) minY = el.y;\n              if (el.y > maxY) maxY = el.y;\n          }\n      } while (stack.length > 0);\n\n      return {\n          data: result,\n          width: image.width,\n          height: image.height,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  }\n  lib.backgroundFillWithBorders = function(image, px, py, colorThreshold, mask, radius = 20) {\n      console.log('backgroundFillWithBordersssss', px, py, colorThreshold);\n      var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\n          data = image.data,\n          w = image.width,\n          h = image.height,\n          bytes = image.bytes, // number of bytes in the color\n          maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\n          i = py * w + px, // start point index in the mask data\n          result = new Uint8Array(mask ? mask : w * h), // result mask\n          visited = new Uint8Array(mask ? mask : w * h); // mask of unvisited points\n\n      console.log('iiiiiiiiiiiiiiii', i, visited[i]);\n      let allVisited = true;\n      for (var dpx = -radius; dpx <= radius; dpx++) {\n          for (var dpy = -radius; dpy <= radius; dpy++) {\n              // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n              if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n              if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n              var k = (py + dpy) * w + px + dpx;\n              if (visited[k] === 1) {\n                  allVisited = false;\n                  break;\n              }\n          }\n          if (!allVisited) break;\n      }\n      if (allVisited) {\n          return null;\n      }\n      // if (visited[i] === 0) {\n      //     return null;\n      // }\n\n      i = i * bytes; // start point index in the image data\n      var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\n\n      // var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\n      var stack = [];\n      for (var dpx = -radius; dpx <= radius; dpx++) {\n          for (var dpy = -radius; dpy <= radius; dpy++) {\n              // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n              if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n              if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n              stack.push({ y: py + dpy, left: px + dpx - 1, right: px + dpx + 1, dir: 1 });\n          }\n      }\n      console.log('stackkkkkk', stack.length);\n      do {\n          el = stack.shift(); // get line for scanning\n\n          checkY = false;\n          for (x = el.left + 1; x < el.right; x++) {\n              dy = el.y * w;\n              i = (dy + x) * bytes; // point index in the image data\n\n              if (visited[dy + x] === 0) continue; // check whether the point has been unvisited\n\n              checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y\n\n              result[dy + x] = 0; // mark a new point in mask\n              visited[dy + x] = 0; // mark a new point as visited\n\n              // console.log('3333333333333', data[i + 3]);\n              // if (data[i + 3] === 0) {    // check by transparent\n              //     continue;\n              // }\n              // compare the color of the sample\n              c = data[i] - sampleColor[0]; // check by red\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 1] - sampleColor[1]; // check by green\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 2] - sampleColor[2]; // check by blue\n              if (c > colorThreshold || c < -colorThreshold) continue;\n\n              xl = x - 1;\n              // walk to left side starting with the left neighbor\n              while (xl > -1) {\n                  dyl = dy + xl;\n                  i = dyl * bytes; // point index in the image data\n                  if (visited[dyl] === 0) break; // check whether the point has been unvisited\n\n                  result[dyl] = 0;\n                  visited[dyl] = 0;\n                  xl--;\n\n                  // if (data[i + 3] === 0) {    // check by transparent\n                  //     break;\n                  // }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n              xr = x + 1;\n              // walk to right side starting with the right neighbor\n              while (xr < w) {\n                  dyr = dy + xr;\n                  i = dyr * bytes; // index point in the image data\n                  if (visited[dyr] === 0) break; // check whether the point has been unvisited\n\n                  result[dyr] = 0;\n                  visited[dyr] = 0;\n                  xr++;\n\n                  // if (data[i + 3] === 0) {    // check by transparent\n                  //     break;\n                  // }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n\n              // check minmax for X\n              if (xl < minX) minX = xl + 1;\n              if (xr > maxX) maxX = xr - 1;\n\n              newY = el.y - el.dir;\n              if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\n                  if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\n                  if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\n              }\n              newY = el.y + el.dir;\n              if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\n                  if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\n              }\n          }\n          // check minmax for Y if necessary\n          if (checkY) {\n              if (el.y < minY) minY = el.y;\n              if (el.y > maxY) maxY = el.y;\n          }\n      } while (stack.length > 0);\n\n      return {\n          data: result,\n          width: image.width,\n          height: image.height,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  }\n  /** Apply the gauss-blur filter to binary mask\n    * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\n    * http://www.librow.com/articles/article-9\n    * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @param {int} blur radius\n    * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    */\n  lib.gaussBlur = function(mask, radius) {\n\n      var i, k, k1, x, y, val, start, end,\n          n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with the center point)\n          s2 = radius * radius,\n          wg = new Float32Array(n), // weights\n          total = 0, // sum of weights(used for normalization)\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY;\n\n      // calc gauss weights\n      for (i = 0; i < radius; i++) {\n          var dsq = (radius - i) * (radius - i);\n          var ww = Math.exp(-dsq / (2.0 * s2)) / (2 * Math.PI * s2);\n          wg[radius + i] = wg[radius - i] = ww;\n          total += 2 * ww;\n      }\n      // normalization weights\n      for (i = 0; i < n; i++) {\n          wg[i] /= total;\n      }\n\n      var result = new Uint8Array(w * h), // result mask\n          endX = radius + w,\n          endY = radius + h;\n\n      //walk through all source points for blur\n      for (y = minY; y < maxY + 1; y++)\n          for (x = minX; x < maxX + 1; x++) {\n              val = 0;\n              k = y * w + x; // index of the point\n              start = radius - x > 0 ? radius - x : 0;\n              end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\n              k1 = k - radius;\n              // walk through x-neighbors\n              for (i = start; i < end; i++) {\n                  val += data[k1 + i] * wg[i];\n              }\n              start = radius - y > 0 ? radius - y : 0;\n              end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\n              k1 = k - radius * w;\n              // walk through y-neighbors\n              for (i = start; i < end; i++) {\n                  val += data[k1 + i * w] * wg[i];\n              }\n              result[k] = val > 0.5 ? 1 : 0;\n          }\n\n      return {\n          data: result,\n          width: w,\n          height: h,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  };\n\n  /** Create a border index array of boundary points of the mask with radius-neighbors\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @param {int} blur radius\n    * @param {Uint8Array} visited: mask of visited points (optional)\n    * @return {Array} border index array of boundary points with radius-neighbors (only points need for blur)\n    */\n  function createBorderForBlur(mask, radius, visited) {\n\n      var x, i, j, y, k, k1, k2,\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          visitedData = new Uint8Array(data),\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          len = w * h,\n          temp = new Uint8Array(len), // auxiliary array to check uniqueness\n          border = [], // only border points\n          x0 = Math.max(minX, 1),\n          x1 = Math.min(maxX, w - 2),\n          y0 = Math.max(minY, 1),\n          y1 = Math.min(maxY, h - 2);\n\n      if (visited && visited.length > 0) {\n          // copy visited points (only \"black\")\n          for (k = 0; k < len; k++) {\n              if (visited[k] === 1) visitedData[k] = 1;\n          }\n      }\n\n      // walk through inner values except points on the boundary of the image\n      for (y = y0; y < y1 + 1; y++)\n          for (x = x0; x < x1 + 1; x++) {\n              k = y * w + x;\n              if (data[k] === 0) continue; // \"white\" point isn't the border\n              k1 = k + w; // y + 1\n              k2 = k - w; // y - 1\n              // check if any neighbor with a \"white\" color\n              if (visitedData[k + 1] === 0 || visitedData[k - 1] === 0 ||\n                  visitedData[k1] === 0 || visitedData[k1 + 1] === 0 || visitedData[k1 - 1] === 0 ||\n                  visitedData[k2] === 0 || visitedData[k2 + 1] === 0 || visitedData[k2 - 1] === 0) {\n                  //if (visitedData[k + 1] + visitedData[k - 1] +\n                  //    visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +\n                  //    visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;\n                  border.push(k);\n              }\n          }\n\n      // walk through points on the boundary of the image if necessary\n      // if the \"black\" point is adjacent to the boundary of the image, it is a border point\n      if (minX == 0)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w] === 1)\n                  border.push(y * w);\n\n      if (maxX == w - 1)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w + maxX] === 1)\n                  border.push(y * w + maxX);\n\n      if (minY == 0)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[x] === 1)\n                  border.push(x);\n\n      if (maxY == h - 1)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[maxY * w + x] === 1)\n                  border.push(maxY * w + x);\n\n      var result = [], // border points with radius-neighbors\n          start, end,\n          endX = radius + w,\n          endY = radius + h,\n          n = radius * 2 + 1; // size of the pattern for radius-neighbors (from -r to +r with the center point)\n\n      len = border.length;\n      // walk through radius-neighbors of border points and add them to the result array\n      for (j = 0; j < len; j++) {\n          k = border[j]; // index of the border point\n          temp[k] = 1; // mark border point\n          result.push(k); // save the border point\n          x = k % w; // calc x by index\n          y = (k - x) / w; // calc y by index\n          start = radius - x > 0 ? radius - x : 0;\n          end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\n          k1 = k - radius;\n          // walk through x-neighbors\n          for (i = start; i < end; i++) {\n              k2 = k1 + i;\n              if (temp[k2] === 0) { // check the uniqueness\n                  temp[k2] = 1;\n                  result.push(k2);\n              }\n          }\n          start = radius - y > 0 ? radius - y : 0;\n          end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\n          k1 = k - radius * w;\n          // walk through y-neighbors\n          for (i = start; i < end; i++) {\n              k2 = k1 + i * w;\n              if (temp[k2] === 0) { // check the uniqueness\n                  temp[k2] = 1;\n                  result.push(k2);\n              }\n          }\n      }\n\n      return result;\n  }\n  /** Apply the gauss-blur filter ONLY to border points with radius-neighbors\n    * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\n    * http://www.librow.com/articles/article-9\n    * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @param {int} blur radius\n    * @param {Uint8Array} visited: mask of visited points (optional)\n    * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    */\n  lib.gaussBlurOnlyBorder = function(mask, radius, visited) {\n\n      var border = createBorderForBlur(mask, radius, visited), // get border points with radius-neighbors\n          ww, dsq, i, j, k, k1, x, y, val, start, end,\n          n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with center point)\n          s2 = 2 * radius * radius,\n          wg = new Float32Array(n), // weights\n          total = 0, // sum of weights(used for normalization)\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          len = border.length;\n\n      // calc gauss weights\n      for (i = 0; i < radius; i++) {\n          dsq = (radius - i) * (radius - i);\n          ww = Math.exp(-dsq / s2) / Math.PI;\n          wg[radius + i] = wg[radius - i] = ww;\n          total += 2 * ww;\n      }\n      // normalization weights\n      for (i = 0; i < n; i++) {\n          wg[i] /= total;\n      }\n\n      var result = new Uint8Array(data), // copy the source mask\n          endX = radius + w,\n          endY = radius + h;\n\n      //walk through all border points for blur\n      for (i = 0; i < len; i++) {\n          k = border[i]; // index of the border point\n          val = 0;\n          x = k % w; // calc x by index\n          y = (k - x) / w; // calc y by index\n          start = radius - x > 0 ? radius - x : 0;\n          end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\n          k1 = k - radius;\n          // walk through x-neighbors\n          for (j = start; j < end; j++) {\n              val += data[k1 + j] * wg[j];\n          }\n          if (val > 0.5) {\n              result[k] = 1;\n              // check minmax\n              if (x < minX) minX = x;\n              if (x > maxX) maxX = x;\n              if (y < minY) minY = y;\n              if (y > maxY) maxY = y;\n              continue;\n          }\n          start = radius - y > 0 ? radius - y : 0;\n          end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\n          k1 = k - radius * w;\n          // walk through y-neighbors\n          for (j = start; j < end; j++) {\n              val += data[k1 + j * w] * wg[j];\n          }\n          if (val > 0.5) {\n              result[k] = 1;\n              // check minmax\n              if (x < minX) minX = x;\n              if (x > maxX) maxX = x;\n              if (y < minY) minY = y;\n              if (y > maxY) maxY = y;\n          } else {\n              result[k] = 0;\n          }\n      }\n\n      return {\n          data: result,\n          width: w,\n          height: h,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  };\n\n  /** Create a border mask (only boundary points)\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\n    */\n  lib.createBorderMask = function(mask) {\n\n      var x, y, k, k1, k2,\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          rw = maxX - minX + 1, // bounds size\n          rh = maxY - minY + 1,\n          result = new Uint8Array(rw * rh), // reduced mask (bounds size)\n          x0 = Math.max(minX, 1),\n          x1 = Math.min(maxX, w - 2),\n          y0 = Math.max(minY, 1),\n          y1 = Math.min(maxY, h - 2);\n\n      // walk through inner values except points on the boundary of the image\n      for (y = y0; y < y1 + 1; y++)\n          for (x = x0; x < x1 + 1; x++) {\n              k = y * w + x;\n              if (data[k] === 0) continue; // \"white\" point isn't the border\n              k1 = k + w; // y + 1\n              k2 = k - w; // y - 1\n              // check if any neighbor with a \"white\" color\n              if (data[k + 1] === 0 || data[k - 1] === 0 ||\n                  data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\n                  data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\n                  //if (data[k + 1] + data[k - 1] +\n                  //    data[k1] + data[k1 + 1] + data[k1 - 1] +\n                  //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\n                  result[(y - minY) * rw + (x - minX)] = 1;\n              }\n          }\n\n      // walk through points on the boundary of the image if necessary\n      // if the \"black\" point is adjacent to the boundary of the image, it is a border point\n      if (minX == 0)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w] === 1)\n                  result[(y - minY) * rw] = 1;\n\n      if (maxX == w - 1)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w + maxX] === 1)\n                  result[(y - minY) * rw + (maxX - minX)] = 1;\n\n      if (minY == 0)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[x] === 1)\n                  result[x - minX] = 1;\n\n      if (maxY == h - 1)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[maxY * w + x] === 1)\n                  result[(maxY - minY) * rw + (x - minX)] = 1;\n\n      return {\n          data: result,\n          width: rw,\n          height: rh,\n          offset: { x: minX, y: minY }\n      };\n  };\n\n  /** Create a border index array of boundary points of the mask\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height\n    * @return {Array} border index array boundary points of the mask\n    */\n  lib.getBorderIndices = function(mask, mainColor = 1) {\n      console.log('getBorderIndicessssssssss', mainColor);\n      var x, y, k, k1, k2,\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          border = [], // only border points\n          x1 = w - 1,\n          y1 = h - 1;\n\n      // if (mainColor === 0) {\n      //     for (y = 0; y < h; y++)\n      //         for (x = 0; x < w; x++) {\n      //             k = y * w + x;\n      //             if (data[k] === 1) continue; // \"black\" point isn't the border\n      //             k1 = k + w; // y + 1\n      //             k2 = k - w; // y - 1\n      //             // check if any neighbor with a \"white\" color\n      //             const count = data[k + 1] + data[k - 1] + data[k1] + data[k1 + 1] + data[k1 - 1] + data[k2] + data[k2 + 1] + data[k2 - 1];\n      //             if (count >= 3) {\n      //                 data[k] = 1;\n      //             }\n      //         }\n      // } else if (mainColor === 1) {\n      //     for (y = 0; y < h; y++)\n      //         for (x = 0; x < w; x++) {\n      //             k = y * w + x;\n      //             if (data[k] === 1) continue; // \"black\" point isn't the border\n      //             k1 = k + w; // y + 1\n      //             k2 = k - w; // y - 1\n      //             // check if any neighbor with a \"white\" color\n      //             const count = data[k + 1] + data[k - 1] + data[k1] + data[k1 + 1] + data[k1 - 1] + data[k2] + data[k2 + 1] + data[k2 - 1];\n      //             if (count >= 3) {\n      //                 data[k] = 1;\n      //             }\n      //         }\n      // }\n      var newMarks;\n      var threshold = 4;\n      var iterations = 0;\n      do {\n          iterations += 1;\n          threshold += 1;\n          newMarks = 0;\n          for (y = 0; y < h; y++)\n              for (x = 0; x < w; x++) {\n                  k = y * w + x;\n                  if (data[k] === mainColor) continue; // \"black\" point isn't the border\n                  k1 = k + w; // y + 1\n                  k2 = k - w; // y - 1\n                  // check if any neighbor with a \"white\" color\n                  var count = 0;\n                  count += 1 * (data[k + 1] === mainColor);\n                  count += 1 * (data[k - 1] === mainColor);\n                  count += 1 * (data[k1] === mainColor);\n                  count += 1 * (data[k1 + 1] === mainColor);\n                  count += 1 * (data[k1 - 1] === mainColor);\n                  count += 1 * (data[k2] === mainColor);\n                  count += 1 * (data[k2 + 1] === mainColor);\n                  count += 1 * (data[k2 - 1] === mainColor);\n                  if (count >= threshold) {\n                      data[k] = mainColor;\n                      newMarks += 1;\n                  }\n              }\n      } while (newMarks > 0 && iterations <= 2);\n      console.log('iterationssssssss', iterations);\n\n      // walk through inner values except points on the boundary of the image\n      for (y = 1; y < y1; y++)\n          for (x = 1; x < x1; x++) {\n              k = y * w + x;\n              if (data[k] === 0) continue; // \"white\" point isn't the border\n              k1 = k + w; // y + 1\n              k2 = k - w; // y - 1\n              // check if any neighbor with a \"white\" color\n              if (data[k + 1] === 0 || data[k - 1] === 0 ||\n                  data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\n                  data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\n                  //if (data[k + 1] + data[k - 1] +\n                  //    data[k1] + data[k1 + 1] + data[k1 - 1] +\n                  //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\n                  border.push(k);\n              }\n          }\n\n      // walk through points on the boundary of the image if necessary\n      // if the \"black\" point is adjacent to the boundary of the image, it is a border point\n      for (y = 0; y < h; y++)\n          if (data[y * w] === 1)\n              border.push(y * w);\n\n      for (x = 0; x < w; x++)\n          if (data[x] === 1)\n              border.push(x);\n\n      k = w - 1;\n      for (y = 0; y < h; y++)\n          if (data[y * w + k] === 1)\n              border.push(y * w + k);\n\n      k = (h - 1) * w;\n      for (x = 0; x < w; x++)\n          if (data[k + x] === 1)\n              border.push(k + x);\n\n      return border;\n  };\n\n  /** Create a compressed mask with a \"white\" border (1px border with zero values) for the contour tracing\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\n    */\n  function prepareMask(mask) {\n      var x, y,\n          w = mask.width,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          rw = maxX - minX + 3, // bounds size +1 px on each side (a \"white\" border)\n          rh = maxY - minY + 3,\n          result = new Uint8Array(rw * rh); // reduced mask (bounds size)\n\n      // walk through inner values and copy only \"black\" points to the result mask\n      for (y = minY; y < maxY + 1; y++)\n          for (x = minX; x < maxX + 1; x++) {\n              if (data[y * w + x] === 1)\n                  result[(y - minY + 1) * rw + (x - minX + 1)] = 1;\n          }\n\n      return {\n          data: result,\n          width: rw,\n          height: rh,\n          offset: { x: minX - 1, y: minY - 1 }\n      };\n  }\n  /** Create a contour array for the binary mask\n    * Algorithm: http://www.sciencedirect.com/science/article/pii/S1077314203001401\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @return {Array} contours: {Array} points, {bool} inner, {int} label\n    */\n  lib.traceContours = function(mask) {\n      var m = prepareMask(mask),\n          contours = [],\n          label = 0,\n          w = m.width,\n          w2 = w * 2,\n          h = m.height,\n          src = m.data,\n          dx = m.offset.x,\n          dy = m.offset.y,\n          dest = new Uint8Array(src), // label matrix\n          i, j, x, y, k, k1, c, inner, dir, first, second, current, previous, next, d;\n\n      // all [dx,dy] pairs (array index is the direction)\n      // 5 6 7\n      // 4 X 0\n      // 3 2 1\n      var directions = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\n\n      for (y = 1; y < h - 1; y++)\n          for (x = 1; x < w - 1; x++) {\n              k = y * w + x;\n              if (src[k] === 1) {\n                  for (i = -w; i < w2; i += w2) { // k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)\n                      if (src[k + i] === 0 && dest[k + i] === 0) { // need contour tracing\n                          inner = i === w; // is inner contour tracing ?\n                          label++; // label for the next contour\n\n                          c = [];\n                          dir = inner ? 2 : 6; // start direction\n                          current = previous = first = { x: x, y: y };\n                          second = null;\n                          while (true) {\n                              dest[current.y * w + current.x] = label; // mark label for the current point\n                              // bypass all the neighbors around the current point in a clockwise\n                              for (j = 0; j < 8; j++) {\n                                  dir = (dir + 1) % 8;\n\n                                  // get the next point by new direction\n                                  d = directions[dir]; // index as direction\n                                  next = { x: current.x + d[0], y: current.y + d[1] };\n\n                                  k1 = next.y * w + next.x;\n                                  if (src[k1] === 1) // black boundary pixel\n                                  {\n                                      dest[k1] = label; // mark a label\n                                      break;\n                                  }\n                                  dest[k1] = -1; // mark a white boundary pixel\n                                  next = null;\n                              }\n                              if (next === null) break; // no neighbours (one-point contour)\n                              current = next;\n                              if (second) {\n                                  if (previous.x === first.x && previous.y === first.y && current.x === second.x && current.y === second.y) {\n                                      break; // creating the contour completed when returned to original position\n                                  }\n                              } else {\n                                  second = next;\n                              }\n                              c.push({ x: previous.x + dx, y: previous.y + dy });\n                              previous = current;\n                              dir = (dir + 4) % 8; // next dir (symmetrically to the current direction)\n                          }\n\n                          if (next != null) {\n                              c.push({ x: first.x + dx, y: first.y + dy }); // close the contour\n                              contours.push({ inner: inner, label: label, points: c }); // add contour to the list\n                          }\n                      }\n                  }\n              }\n          }\n\n      return contours;\n  };\n\n  /** Simplify contours\n    * Algorithms: http://psimpl.sourceforge.net/douglas-peucker.html\n    * http://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B8%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%86%D0%B5%D0%BF%D0%B8\n    * @param {Array} contours: {Array} points, {bool} inner, {int} label\n    * @param {float} simplify tolerant\n    * @param {int} simplify count: min number of points when the contour is simplified\n    * @return {Array} contours: {Array} points, {bool} inner, {int} label, {int} initialCount\n    */\n  lib.simplifyContours = function(contours, simplifyTolerant, simplifyCount) {\n      var lenContours = contours.length,\n          result = [],\n          i, j, k, c, points, len, resPoints, lst, stack, ids,\n          maxd, maxi, dist, r1, r2, r12, dx, dy, pi, pf, pl;\n\n      // walk through all contours\n      for (j = 0; j < lenContours; j++) {\n          c = contours[j];\n          points = c.points;\n          len = c.points.length;\n\n          if (len < simplifyCount) { // contour isn't simplified\n              resPoints = [];\n              for (k = 0; k < len; k++) {\n                  resPoints.push({ x: points[k].x, y: points[k].y });\n              }\n              result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: len });\n              continue;\n          }\n\n          lst = [0, len - 1]; // always add first and last points\n          stack = [{ first: 0, last: len - 1 }]; // first processed edge\n\n          do {\n              ids = stack.shift();\n              if (ids.last <= ids.first + 1) // no intermediate points\n              {\n                  continue;\n              }\n\n              maxd = -1.0; // max distance from point to current edge\n              maxi = ids.first; // index of maximally distant point\n\n              for (i = ids.first + 1; i < ids.last; i++) // bypass intermediate points in edge\n              {\n                  // calc the distance from current point to edge\n                  pi = points[i];\n                  pf = points[ids.first];\n                  pl = points[ids.last];\n                  dx = pi.x - pf.x;\n                  dy = pi.y - pf.y;\n                  r1 = Math.sqrt(dx * dx + dy * dy);\n                  dx = pi.x - pl.x;\n                  dy = pi.y - pl.y;\n                  r2 = Math.sqrt(dx * dx + dy * dy);\n                  dx = pf.x - pl.x;\n                  dy = pf.y - pl.y;\n                  r12 = Math.sqrt(dx * dx + dy * dy);\n                  if (r1 >= Math.sqrt(r2 * r2 + r12 * r12)) dist = r2;\n                  else if (r2 >= Math.sqrt(r1 * r1 + r12 * r12)) dist = r1;\n                  else dist = Math.abs((dy * pi.x - dx * pi.y + pf.x * pl.y - pl.x * pf.y) / r12);\n\n                  if (dist > maxd) {\n                      maxi = i; // save the index of maximally distant point\n                      maxd = dist;\n                  }\n              }\n\n              if (maxd > simplifyTolerant) // if the max \"deviation\" is larger than allowed then...\n              {\n                  lst.push(maxi); // add index to the simplified list\n                  stack.push({ first: ids.first, last: maxi }); // add the left part for processing\n                  stack.push({ first: maxi, last: ids.last }); // add the right part for processing\n              }\n\n          } while (stack.length > 0);\n\n          resPoints = [];\n          len = lst.length;\n          lst.sort(function(a, b) { return a - b; }); // restore index order\n          for (k = 0; k < len; k++) {\n              resPoints.push({ x: points[lst[k]].x, y: points[lst[k]].y }); // add result points to the correct order\n          }\n          result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: c.points.length });\n      }\n\n      return result;\n  };\n\n  return lib;\n})();\n\nmodule.exports = MagicWand;\n//# sourceMappingURL=magic-wand.js.map\n"],"names":[],"mappings":"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"}
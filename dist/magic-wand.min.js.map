{"version":3,"file":"magic-wand.min.js","sources":["../src/MagicWand.js"],"sourcesContent":["ï»¿/*\n Magic wand tool (fuzzy selection) by color\n\n @package magic-wand-tool\n @author Ryasnoy Paul <ryasnoypaul@gmail.com>\n @version 1.1.4\n @license MIT\n @copyright (c) 2014-2019, Ryasnoy Paul <ryasnoypaul@gmail.com>\n\n*/\n\nMagicWand = (function () {\n  var lib = {};\n\n  /** Create a binary mask on the image by color threshold\n    * Algorithm: Scanline flood fill (http://en.wikipedia.org/wiki/Flood_fill)\n    * @param {Object} image: {Uint8Array} data, {int} width, {int} height, {int} bytes\n    * @param {int} x of start pixel\n    * @param {int} y of start pixel\n    * @param {int} color threshold\n    * @param {Uint8Array} mask of visited points (optional)\n    * @param {boolean} [includeBorders=false] indicate whether to include borders pixels\n    * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    */\n  lib.floodFill = function(image, px, py, extraX, extraY, colorThreshold, mask, includeBorders, radius = 20) {\n      return includeBorders\n          ? floodFillWithBorders(image, px, py, extraX, extraY, colorThreshold, mask, radius)\n          : floodFillWithoutBorders(image, px, py, colorThreshold, mask);\n  };\n\n  function floodFillWithoutBorders(image, px, py, colorThreshold, mask) {\n\n      var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\n          data = image.data,\n          w = image.width,\n          h = image.height,\n          bytes = image.bytes, // number of bytes in the color\n          maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\n          i = py * w + px, // start point index in the mask data\n          result = new Uint8Array(w * h), // result mask\n          visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\n\n      if (visited[i] === 1) return null;\n\n      i = i * bytes; // start point index in the image data\n      var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\n\n      var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\n      do {\n          el = stack.shift(); // get line for scanning\n\n          checkY = false;\n          for (x = el.left + 1; x < el.right; x++) {\n              dy = el.y * w;\n              i = (dy + x) * bytes; // point index in the image data\n\n              if (visited[dy + x] === 1) continue; // check whether the point has been visited\n              // compare the color of the sample\n              c = data[i] - sampleColor[0]; // check by red\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 1] - sampleColor[1]; // check by green\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 2] - sampleColor[2]; // check by blue\n              if (c > colorThreshold || c < -colorThreshold) continue;\n\n              checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y\n\n              result[dy + x] = 1; // mark a new point in mask\n              visited[dy + x] = 1; // mark a new point as visited\n\n              xl = x - 1;\n              // walk to left side starting with the left neighbor\n              while (xl > -1) {\n                  dyl = dy + xl;\n                  i = dyl * bytes; // point index in the image data\n                  if (visited[dyl] === 1) break; // check whether the point has been visited\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n\n                  result[dyl] = 1;\n                  visited[dyl] = 1;\n\n                  xl--;\n              }\n              xr = x + 1;\n              // walk to right side starting with the right neighbor\n              while (xr < w) {\n                  dyr = dy + xr;\n                  i = dyr * bytes; // index point in the image data\n                  if (visited[dyr] === 1) break; // check whether the point has been visited\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n\n                  result[dyr] = 1;\n                  visited[dyr] = 1;\n\n                  xr++;\n              }\n\n              // check minmax for X\n              if (xl < minX) minX = xl + 1;\n              if (xr > maxX) maxX = xr - 1;\n\n              newY = el.y - el.dir;\n              if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\n                  if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\n                  if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\n              }\n              newY = el.y + el.dir;\n              if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\n                  if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\n              }\n          }\n          // check minmax for Y if necessary\n          if (checkY) {\n              if (el.y < minY) minY = el.y;\n              if (el.y > maxY) maxY = el.y;\n          }\n      } while (stack.length > 0);\n\n      return {\n          data: result,\n          width: image.width,\n          height: image.height,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  }\n  function distance(x1, y1, x2, y2) {\n      var dx = Math.abs(x1 - x2);\n      var dy = Math.abs(y1 - y2);\n      return Math.sqrt(dx * dx + dy * dy);\n  }\n  function floodFillWithBorders(image, px, py, extraX, extraY, colorThreshold, mask, radius) {\n      console.log('floodFillWithBordersssssssss', px, py, colorThreshold);\n      var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\n          data = image.data,\n          w = image.width,\n          h = image.height,\n          bytes = image.bytes, // number of bytes in the color\n          maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\n          i = py * w + px, // start point index in the mask data\n          result = new Uint8Array(mask ? mask : w * h), // result mask\n          visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\n\n      // console.log('iiiiiiiiiiiiiiii', i);\n      // console.log('iiiii22222222222', result);\n      // console.log('iiiii33333333333', visited);\n      let allVisited = true;\n      if (extraX !== null && extraY !== null) {\n          console.log('extraaaaaaaaaa', extraX, extraY);\n          for (var dpx = -radius; dpx <= radius; dpx++) {\n              for (var dpy = -radius; dpy <= radius; dpy++) {\n                  // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n                  if (extraY + dpy < 0 || extraY + dpy >= h || extraX + dpx < 0 || extraX + dpx >= w) continue;\n                  if (distance(extraX, extraY, extraX + dpx, extraY + dpy) > radius) continue;\n                  var k = (extraY + dpy) * w + extraX + dpx;\n                  if (visited[k] === 0) {\n                      // visited[k] = 1;\n                      result[k] = 1;\n                      allVisited = false;\n                  }\n              }\n          }\n      } else {\n          for (var dpx = -radius; dpx <= radius; dpx++) {\n              for (var dpy = -radius; dpy <= radius; dpy++) {\n                  if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n                  if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n                  var k = (py + dpy) * w + px + dpx;\n                  if (visited[k] === 0) {\n                      allVisited = false;\n                      break;\n                  }\n              }\n              if (!allVisited) break;\n          }\n      }\n      if (allVisited) {\n          return null;\n      }\n\n      i = i * bytes; // start point index in the image data\n      var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\n\n      // var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\n      var stack = [];\n      for (var dpx = -radius; dpx <= radius; dpx++) {\n          for (var dpy = -radius; dpy <= radius; dpy++) {\n              // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n              if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n              if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n              stack.push({ y: py + dpy, left: px + dpx - 1, right: px + dpx + 1, dir: 1 });\n          }\n      }\n      console.log('stackkkkkk', stack.length);\n      do {\n          el = stack.shift(); // get line for scanning\n\n          checkY = false;\n          for (x = el.left + 1; x < el.right; x++) {\n              dy = el.y * w;\n              i = (dy + x) * bytes; // point index in the image data\n\n              if (visited[dy + x] === 1) continue; // check whether the point has been visited\n\n              checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y\n\n              result[dy + x] = 1; // mark a new point in mask\n              visited[dy + x] = 1; // mark a new point as visited\n\n              // console.log('3333333333333', data[i + 3]);\n              if (data[i + 3] === 0) {\n                  continue;\n              }\n              // compare the color of the sample\n              c = data[i] - sampleColor[0]; // check by red\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 1] - sampleColor[1]; // check by green\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 2] - sampleColor[2]; // check by blue\n              if (c > colorThreshold || c < -colorThreshold) continue;\n\n              xl = x - 1;\n              // walk to left side starting with the left neighbor\n              while (xl > -1) {\n                  dyl = dy + xl;\n                  i = dyl * bytes; // point index in the image data\n                  if (visited[dyl] === 1) break; // check whether the point has been visited\n\n                  result[dyl] = 1;\n                  visited[dyl] = 1;\n                  xl--;\n\n                  if (data[i + 3] === 0) {\n                      break;\n                  }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n              xr = x + 1;\n              // walk to right side starting with the right neighbor\n              while (xr < w) {\n                  dyr = dy + xr;\n                  i = dyr * bytes; // index point in the image data\n                  if (visited[dyr] === 1) break; // check whether the point has been visited\n\n                  result[dyr] = 1;\n                  visited[dyr] = 1;\n                  xr++;\n\n                  if (data[i + 3] === 0) {\n                      break;\n                  }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n\n              // check minmax for X\n              if (xl < minX) minX = xl + 1;\n              if (xr > maxX) maxX = xr - 1;\n\n              newY = el.y - el.dir;\n              if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\n                  if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\n                  if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\n              }\n              newY = el.y + el.dir;\n              if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\n                  if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\n              }\n          }\n          // check minmax for Y if necessary\n          if (checkY) {\n              if (el.y < minY) minY = el.y;\n              if (el.y > maxY) maxY = el.y;\n          }\n      } while (stack.length > 0);\n\n      return {\n          data: result,\n          width: image.width,\n          height: image.height,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  }\n  lib.backgroundFillWithBorders = function(image, px, py, colorThreshold, mask, radius = 20) {\n      console.log('backgroundFillWithBordersssss', px, py, colorThreshold);\n      var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\n          data = image.data,\n          w = image.width,\n          h = image.height,\n          bytes = image.bytes, // number of bytes in the color\n          maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\n          i = py * w + px, // start point index in the mask data\n          result = new Uint8Array(mask ? mask : w * h), // result mask\n          visited = new Uint8Array(mask ? mask : w * h); // mask of unvisited points\n\n      console.log('iiiiiiiiiiiiiiii', i, visited[i]);\n      let allVisited = true;\n      for (var dpx = -radius; dpx <= radius; dpx++) {\n          for (var dpy = -radius; dpy <= radius; dpy++) {\n              // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n              if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n              if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n              var k = (py + dpy) * w + px + dpx;\n              if (visited[k] === 1) {\n                  allVisited = false;\n                  break;\n              }\n          }\n          if (!allVisited) break;\n      }\n      if (allVisited) {\n          return null;\n      }\n      // if (visited[i] === 0) {\n      //     return null;\n      // }\n\n      i = i * bytes; // start point index in the image data\n      var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\n\n      // var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\n      var stack = [];\n      for (var dpx = -radius; dpx <= radius; dpx++) {\n          for (var dpy = -radius; dpy <= radius; dpy++) {\n              // if (Math.abs(dpx) + Math.abs(dpy) > radius) continue;\n              if (py + dpy < 0 || py + dpy >= h || px + dpx < 0 || px + dpx >= w) continue;\n              if (distance(px, py, px + dpx, py + dpy) > radius) continue;\n              stack.push({ y: py + dpy, left: px + dpx - 1, right: px + dpx + 1, dir: 1 });\n          }\n      }\n      console.log('stackkkkkk', stack.length);\n      do {\n          el = stack.shift(); // get line for scanning\n\n          checkY = false;\n          for (x = el.left + 1; x < el.right; x++) {\n              dy = el.y * w;\n              i = (dy + x) * bytes; // point index in the image data\n\n              if (visited[dy + x] === 0) continue; // check whether the point has been unvisited\n\n              checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y\n\n              result[dy + x] = 0; // mark a new point in mask\n              visited[dy + x] = 0; // mark a new point as visited\n\n              // console.log('3333333333333', data[i + 3]);\n              // if (data[i + 3] === 0) {    // check by transparent\n              //     continue;\n              // }\n              // compare the color of the sample\n              c = data[i] - sampleColor[0]; // check by red\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 1] - sampleColor[1]; // check by green\n              if (c > colorThreshold || c < -colorThreshold) continue;\n              c = data[i + 2] - sampleColor[2]; // check by blue\n              if (c > colorThreshold || c < -colorThreshold) continue;\n\n              xl = x - 1;\n              // walk to left side starting with the left neighbor\n              while (xl > -1) {\n                  dyl = dy + xl;\n                  i = dyl * bytes; // point index in the image data\n                  if (visited[dyl] === 0) break; // check whether the point has been unvisited\n\n                  result[dyl] = 0;\n                  visited[dyl] = 0;\n                  xl--;\n\n                  // if (data[i + 3] === 0) {    // check by transparent\n                  //     break;\n                  // }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n              xr = x + 1;\n              // walk to right side starting with the right neighbor\n              while (xr < w) {\n                  dyr = dy + xr;\n                  i = dyr * bytes; // index point in the image data\n                  if (visited[dyr] === 0) break; // check whether the point has been unvisited\n\n                  result[dyr] = 0;\n                  visited[dyr] = 0;\n                  xr++;\n\n                  // if (data[i + 3] === 0) {    // check by transparent\n                  //     break;\n                  // }\n                  // compare the color of the sample\n                  c = data[i] - sampleColor[0]; // check by red\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 1] - sampleColor[1]; // check by green\n                  if (c > colorThreshold || c < -colorThreshold) break;\n                  c = data[i + 2] - sampleColor[2]; // check by blue\n                  if (c > colorThreshold || c < -colorThreshold) break;\n              }\n\n              // check minmax for X\n              if (xl < minX) minX = xl + 1;\n              if (xr > maxX) maxX = xr - 1;\n\n              newY = el.y - el.dir;\n              if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\n                  if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\n                  if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\n              }\n              newY = el.y + el.dir;\n              if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\n                  if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\n              }\n          }\n          // check minmax for Y if necessary\n          if (checkY) {\n              if (el.y < minY) minY = el.y;\n              if (el.y > maxY) maxY = el.y;\n          }\n      } while (stack.length > 0);\n\n      return {\n          data: result,\n          width: image.width,\n          height: image.height,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  }\n  /** Apply the gauss-blur filter to binary mask\n    * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\n    * http://www.librow.com/articles/article-9\n    * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @param {int} blur radius\n    * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    */\n  lib.gaussBlur = function(mask, radius) {\n\n      var i, k, k1, x, y, val, start, end,\n          n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with the center point)\n          s2 = radius * radius,\n          wg = new Float32Array(n), // weights\n          total = 0, // sum of weights(used for normalization)\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY;\n\n      // calc gauss weights\n      for (i = 0; i < radius; i++) {\n          var dsq = (radius - i) * (radius - i);\n          var ww = Math.exp(-dsq / (2.0 * s2)) / (2 * Math.PI * s2);\n          wg[radius + i] = wg[radius - i] = ww;\n          total += 2 * ww;\n      }\n      // normalization weights\n      for (i = 0; i < n; i++) {\n          wg[i] /= total;\n      }\n\n      var result = new Uint8Array(w * h), // result mask\n          endX = radius + w,\n          endY = radius + h;\n\n      //walk through all source points for blur\n      for (y = minY; y < maxY + 1; y++)\n          for (x = minX; x < maxX + 1; x++) {\n              val = 0;\n              k = y * w + x; // index of the point\n              start = radius - x > 0 ? radius - x : 0;\n              end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\n              k1 = k - radius;\n              // walk through x-neighbors\n              for (i = start; i < end; i++) {\n                  val += data[k1 + i] * wg[i];\n              }\n              start = radius - y > 0 ? radius - y : 0;\n              end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\n              k1 = k - radius * w;\n              // walk through y-neighbors\n              for (i = start; i < end; i++) {\n                  val += data[k1 + i * w] * wg[i];\n              }\n              result[k] = val > 0.5 ? 1 : 0;\n          }\n\n      return {\n          data: result,\n          width: w,\n          height: h,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  };\n\n  /** Create a border index array of boundary points of the mask with radius-neighbors\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @param {int} blur radius\n    * @param {Uint8Array} visited: mask of visited points (optional)\n    * @return {Array} border index array of boundary points with radius-neighbors (only points need for blur)\n    */\n  function createBorderForBlur(mask, radius, visited) {\n\n      var x, i, j, y, k, k1, k2,\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          visitedData = new Uint8Array(data),\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          len = w * h,\n          temp = new Uint8Array(len), // auxiliary array to check uniqueness\n          border = [], // only border points\n          x0 = Math.max(minX, 1),\n          x1 = Math.min(maxX, w - 2),\n          y0 = Math.max(minY, 1),\n          y1 = Math.min(maxY, h - 2);\n\n      if (visited && visited.length > 0) {\n          // copy visited points (only \"black\")\n          for (k = 0; k < len; k++) {\n              if (visited[k] === 1) visitedData[k] = 1;\n          }\n      }\n\n      // walk through inner values except points on the boundary of the image\n      for (y = y0; y < y1 + 1; y++)\n          for (x = x0; x < x1 + 1; x++) {\n              k = y * w + x;\n              if (data[k] === 0) continue; // \"white\" point isn't the border\n              k1 = k + w; // y + 1\n              k2 = k - w; // y - 1\n              // check if any neighbor with a \"white\" color\n              if (visitedData[k + 1] === 0 || visitedData[k - 1] === 0 ||\n                  visitedData[k1] === 0 || visitedData[k1 + 1] === 0 || visitedData[k1 - 1] === 0 ||\n                  visitedData[k2] === 0 || visitedData[k2 + 1] === 0 || visitedData[k2 - 1] === 0) {\n                  //if (visitedData[k + 1] + visitedData[k - 1] +\n                  //    visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +\n                  //    visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;\n                  border.push(k);\n              }\n          }\n\n      // walk through points on the boundary of the image if necessary\n      // if the \"black\" point is adjacent to the boundary of the image, it is a border point\n      if (minX == 0)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w] === 1)\n                  border.push(y * w);\n\n      if (maxX == w - 1)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w + maxX] === 1)\n                  border.push(y * w + maxX);\n\n      if (minY == 0)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[x] === 1)\n                  border.push(x);\n\n      if (maxY == h - 1)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[maxY * w + x] === 1)\n                  border.push(maxY * w + x);\n\n      var result = [], // border points with radius-neighbors\n          start, end,\n          endX = radius + w,\n          endY = radius + h,\n          n = radius * 2 + 1; // size of the pattern for radius-neighbors (from -r to +r with the center point)\n\n      len = border.length;\n      // walk through radius-neighbors of border points and add them to the result array\n      for (j = 0; j < len; j++) {\n          k = border[j]; // index of the border point\n          temp[k] = 1; // mark border point\n          result.push(k); // save the border point\n          x = k % w; // calc x by index\n          y = (k - x) / w; // calc y by index\n          start = radius - x > 0 ? radius - x : 0;\n          end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\n          k1 = k - radius;\n          // walk through x-neighbors\n          for (i = start; i < end; i++) {\n              k2 = k1 + i;\n              if (temp[k2] === 0) { // check the uniqueness\n                  temp[k2] = 1;\n                  result.push(k2);\n              }\n          }\n          start = radius - y > 0 ? radius - y : 0;\n          end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\n          k1 = k - radius * w;\n          // walk through y-neighbors\n          for (i = start; i < end; i++) {\n              k2 = k1 + i * w;\n              if (temp[k2] === 0) { // check the uniqueness\n                  temp[k2] = 1;\n                  result.push(k2);\n              }\n          }\n      }\n\n      return result;\n  }\n  /** Apply the gauss-blur filter ONLY to border points with radius-neighbors\n    * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\n    * http://www.librow.com/articles/article-9\n    * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @param {int} blur radius\n    * @param {Uint8Array} visited: mask of visited points (optional)\n    * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    */\n  lib.gaussBlurOnlyBorder = function(mask, radius, visited) {\n\n      var border = createBorderForBlur(mask, radius, visited), // get border points with radius-neighbors\n          ww, dsq, i, j, k, k1, x, y, val, start, end,\n          n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with center point)\n          s2 = 2 * radius * radius,\n          wg = new Float32Array(n), // weights\n          total = 0, // sum of weights(used for normalization)\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          len = border.length;\n\n      // calc gauss weights\n      for (i = 0; i < radius; i++) {\n          dsq = (radius - i) * (radius - i);\n          ww = Math.exp(-dsq / s2) / Math.PI;\n          wg[radius + i] = wg[radius - i] = ww;\n          total += 2 * ww;\n      }\n      // normalization weights\n      for (i = 0; i < n; i++) {\n          wg[i] /= total;\n      }\n\n      var result = new Uint8Array(data), // copy the source mask\n          endX = radius + w,\n          endY = radius + h;\n\n      //walk through all border points for blur\n      for (i = 0; i < len; i++) {\n          k = border[i]; // index of the border point\n          val = 0;\n          x = k % w; // calc x by index\n          y = (k - x) / w; // calc y by index\n          start = radius - x > 0 ? radius - x : 0;\n          end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\n          k1 = k - radius;\n          // walk through x-neighbors\n          for (j = start; j < end; j++) {\n              val += data[k1 + j] * wg[j];\n          }\n          if (val > 0.5) {\n              result[k] = 1;\n              // check minmax\n              if (x < minX) minX = x;\n              if (x > maxX) maxX = x;\n              if (y < minY) minY = y;\n              if (y > maxY) maxY = y;\n              continue;\n          }\n          start = radius - y > 0 ? radius - y : 0;\n          end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\n          k1 = k - radius * w;\n          // walk through y-neighbors\n          for (j = start; j < end; j++) {\n              val += data[k1 + j * w] * wg[j];\n          }\n          if (val > 0.5) {\n              result[k] = 1;\n              // check minmax\n              if (x < minX) minX = x;\n              if (x > maxX) maxX = x;\n              if (y < minY) minY = y;\n              if (y > maxY) maxY = y;\n          } else {\n              result[k] = 0;\n          }\n      }\n\n      return {\n          data: result,\n          width: w,\n          height: h,\n          bounds: {\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n          }\n      };\n  };\n\n  /** Create a border mask (only boundary points)\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\n    */\n  lib.createBorderMask = function(mask) {\n\n      var x, y, k, k1, k2,\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          rw = maxX - minX + 1, // bounds size\n          rh = maxY - minY + 1,\n          result = new Uint8Array(rw * rh), // reduced mask (bounds size)\n          x0 = Math.max(minX, 1),\n          x1 = Math.min(maxX, w - 2),\n          y0 = Math.max(minY, 1),\n          y1 = Math.min(maxY, h - 2);\n\n      // walk through inner values except points on the boundary of the image\n      for (y = y0; y < y1 + 1; y++)\n          for (x = x0; x < x1 + 1; x++) {\n              k = y * w + x;\n              if (data[k] === 0) continue; // \"white\" point isn't the border\n              k1 = k + w; // y + 1\n              k2 = k - w; // y - 1\n              // check if any neighbor with a \"white\" color\n              if (data[k + 1] === 0 || data[k - 1] === 0 ||\n                  data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\n                  data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\n                  //if (data[k + 1] + data[k - 1] +\n                  //    data[k1] + data[k1 + 1] + data[k1 - 1] +\n                  //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\n                  result[(y - minY) * rw + (x - minX)] = 1;\n              }\n          }\n\n      // walk through points on the boundary of the image if necessary\n      // if the \"black\" point is adjacent to the boundary of the image, it is a border point\n      if (minX == 0)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w] === 1)\n                  result[(y - minY) * rw] = 1;\n\n      if (maxX == w - 1)\n          for (y = minY; y < maxY + 1; y++)\n              if (data[y * w + maxX] === 1)\n                  result[(y - minY) * rw + (maxX - minX)] = 1;\n\n      if (minY == 0)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[x] === 1)\n                  result[x - minX] = 1;\n\n      if (maxY == h - 1)\n          for (x = minX; x < maxX + 1; x++)\n              if (data[maxY * w + x] === 1)\n                  result[(maxY - minY) * rw + (x - minX)] = 1;\n\n      return {\n          data: result,\n          width: rw,\n          height: rh,\n          offset: { x: minX, y: minY }\n      };\n  };\n\n  /** Create a border index array of boundary points of the mask\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height\n    * @return {Array} border index array boundary points of the mask\n    */\n  lib.getBorderIndices = function(mask, mainColor = 1) {\n      console.log('getBorderIndicessssssssss', mainColor);\n      var x, y, k, k1, k2,\n          w = mask.width,\n          h = mask.height,\n          data = mask.data,\n          border = [], // only border points\n          x1 = w - 1,\n          y1 = h - 1;\n\n      // if (mainColor === 0) {\n      //     for (y = 0; y < h; y++)\n      //         for (x = 0; x < w; x++) {\n      //             k = y * w + x;\n      //             if (data[k] === 1) continue; // \"black\" point isn't the border\n      //             k1 = k + w; // y + 1\n      //             k2 = k - w; // y - 1\n      //             // check if any neighbor with a \"white\" color\n      //             const count = data[k + 1] + data[k - 1] + data[k1] + data[k1 + 1] + data[k1 - 1] + data[k2] + data[k2 + 1] + data[k2 - 1];\n      //             if (count >= 3) {\n      //                 data[k] = 1;\n      //             }\n      //         }\n      // } else if (mainColor === 1) {\n      //     for (y = 0; y < h; y++)\n      //         for (x = 0; x < w; x++) {\n      //             k = y * w + x;\n      //             if (data[k] === 1) continue; // \"black\" point isn't the border\n      //             k1 = k + w; // y + 1\n      //             k2 = k - w; // y - 1\n      //             // check if any neighbor with a \"white\" color\n      //             const count = data[k + 1] + data[k - 1] + data[k1] + data[k1 + 1] + data[k1 - 1] + data[k2] + data[k2 + 1] + data[k2 - 1];\n      //             if (count >= 3) {\n      //                 data[k] = 1;\n      //             }\n      //         }\n      // }\n      var newMarks;\n      var threshold = 4;\n      var iterations = 0;\n      do {\n          iterations += 1;\n          threshold += 1;\n          newMarks = 0;\n          for (y = 0; y < h; y++)\n              for (x = 0; x < w; x++) {\n                  k = y * w + x;\n                  if (data[k] === mainColor) continue; // \"black\" point isn't the border\n                  k1 = k + w; // y + 1\n                  k2 = k - w; // y - 1\n                  // check if any neighbor with a \"white\" color\n                  var count = 0;\n                  count += 1 * (data[k + 1] === mainColor);\n                  count += 1 * (data[k - 1] === mainColor);\n                  count += 1 * (data[k1] === mainColor);\n                  count += 1 * (data[k1 + 1] === mainColor);\n                  count += 1 * (data[k1 - 1] === mainColor);\n                  count += 1 * (data[k2] === mainColor);\n                  count += 1 * (data[k2 + 1] === mainColor);\n                  count += 1 * (data[k2 - 1] === mainColor);\n                  if (count >= threshold) {\n                      data[k] = mainColor;\n                      newMarks += 1;\n                  }\n              }\n      } while (newMarks > 0 && iterations <= 2);\n      console.log('iterationssssssss', iterations);\n\n      // walk through inner values except points on the boundary of the image\n      for (y = 1; y < y1; y++)\n          for (x = 1; x < x1; x++) {\n              k = y * w + x;\n              if (data[k] === 0) continue; // \"white\" point isn't the border\n              k1 = k + w; // y + 1\n              k2 = k - w; // y - 1\n              // check if any neighbor with a \"white\" color\n              if (data[k + 1] === 0 || data[k - 1] === 0 ||\n                  data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\n                  data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\n                  //if (data[k + 1] + data[k - 1] +\n                  //    data[k1] + data[k1 + 1] + data[k1 - 1] +\n                  //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\n                  border.push(k);\n              }\n          }\n\n      // walk through points on the boundary of the image if necessary\n      // if the \"black\" point is adjacent to the boundary of the image, it is a border point\n      for (y = 0; y < h; y++)\n          if (data[y * w] === 1)\n              border.push(y * w);\n\n      for (x = 0; x < w; x++)\n          if (data[x] === 1)\n              border.push(x);\n\n      k = w - 1;\n      for (y = 0; y < h; y++)\n          if (data[y * w + k] === 1)\n              border.push(y * w + k);\n\n      k = (h - 1) * w;\n      for (x = 0; x < w; x++)\n          if (data[k + x] === 1)\n              border.push(k + x);\n\n      return border;\n  };\n\n  /** Create a compressed mask with a \"white\" border (1px border with zero values) for the contour tracing\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\n    */\n  function prepareMask(mask) {\n      var x, y,\n          w = mask.width,\n          data = mask.data,\n          minX = mask.bounds.minX,\n          maxX = mask.bounds.maxX,\n          minY = mask.bounds.minY,\n          maxY = mask.bounds.maxY,\n          rw = maxX - minX + 3, // bounds size +1 px on each side (a \"white\" border)\n          rh = maxY - minY + 3,\n          result = new Uint8Array(rw * rh); // reduced mask (bounds size)\n\n      // walk through inner values and copy only \"black\" points to the result mask\n      for (y = minY; y < maxY + 1; y++)\n          for (x = minX; x < maxX + 1; x++) {\n              if (data[y * w + x] === 1)\n                  result[(y - minY + 1) * rw + (x - minX + 1)] = 1;\n          }\n\n      return {\n          data: result,\n          width: rw,\n          height: rh,\n          offset: { x: minX - 1, y: minY - 1 }\n      };\n  }\n  /** Create a contour array for the binary mask\n    * Algorithm: http://www.sciencedirect.com/science/article/pii/S1077314203001401\n    * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\n    * @return {Array} contours: {Array} points, {bool} inner, {int} label\n    */\n  lib.traceContours = function(mask) {\n      var m = prepareMask(mask),\n          contours = [],\n          label = 0,\n          w = m.width,\n          w2 = w * 2,\n          h = m.height,\n          src = m.data,\n          dx = m.offset.x,\n          dy = m.offset.y,\n          dest = new Uint8Array(src), // label matrix\n          i, j, x, y, k, k1, c, inner, dir, first, second, current, previous, next, d;\n\n      // all [dx,dy] pairs (array index is the direction)\n      // 5 6 7\n      // 4 X 0\n      // 3 2 1\n      var directions = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\n\n      for (y = 1; y < h - 1; y++)\n          for (x = 1; x < w - 1; x++) {\n              k = y * w + x;\n              if (src[k] === 1) {\n                  for (i = -w; i < w2; i += w2) { // k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)\n                      if (src[k + i] === 0 && dest[k + i] === 0) { // need contour tracing\n                          inner = i === w; // is inner contour tracing ?\n                          label++; // label for the next contour\n\n                          c = [];\n                          dir = inner ? 2 : 6; // start direction\n                          current = previous = first = { x: x, y: y };\n                          second = null;\n                          while (true) {\n                              dest[current.y * w + current.x] = label; // mark label for the current point\n                              // bypass all the neighbors around the current point in a clockwise\n                              for (j = 0; j < 8; j++) {\n                                  dir = (dir + 1) % 8;\n\n                                  // get the next point by new direction\n                                  d = directions[dir]; // index as direction\n                                  next = { x: current.x + d[0], y: current.y + d[1] };\n\n                                  k1 = next.y * w + next.x;\n                                  if (src[k1] === 1) // black boundary pixel\n                                  {\n                                      dest[k1] = label; // mark a label\n                                      break;\n                                  }\n                                  dest[k1] = -1; // mark a white boundary pixel\n                                  next = null;\n                              }\n                              if (next === null) break; // no neighbours (one-point contour)\n                              current = next;\n                              if (second) {\n                                  if (previous.x === first.x && previous.y === first.y && current.x === second.x && current.y === second.y) {\n                                      break; // creating the contour completed when returned to original position\n                                  }\n                              } else {\n                                  second = next;\n                              }\n                              c.push({ x: previous.x + dx, y: previous.y + dy });\n                              previous = current;\n                              dir = (dir + 4) % 8; // next dir (symmetrically to the current direction)\n                          }\n\n                          if (next != null) {\n                              c.push({ x: first.x + dx, y: first.y + dy }); // close the contour\n                              contours.push({ inner: inner, label: label, points: c }); // add contour to the list\n                          }\n                      }\n                  }\n              }\n          }\n\n      return contours;\n  };\n\n  /** Simplify contours\n    * Algorithms: http://psimpl.sourceforge.net/douglas-peucker.html\n    * http://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B8%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%86%D0%B5%D0%BF%D0%B8\n    * @param {Array} contours: {Array} points, {bool} inner, {int} label\n    * @param {float} simplify tolerant\n    * @param {int} simplify count: min number of points when the contour is simplified\n    * @return {Array} contours: {Array} points, {bool} inner, {int} label, {int} initialCount\n    */\n  lib.simplifyContours = function(contours, simplifyTolerant, simplifyCount) {\n      var lenContours = contours.length,\n          result = [],\n          i, j, k, c, points, len, resPoints, lst, stack, ids,\n          maxd, maxi, dist, r1, r2, r12, dx, dy, pi, pf, pl;\n\n      // walk through all contours\n      for (j = 0; j < lenContours; j++) {\n          c = contours[j];\n          points = c.points;\n          len = c.points.length;\n\n          if (len < simplifyCount) { // contour isn't simplified\n              resPoints = [];\n              for (k = 0; k < len; k++) {\n                  resPoints.push({ x: points[k].x, y: points[k].y });\n              }\n              result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: len });\n              continue;\n          }\n\n          lst = [0, len - 1]; // always add first and last points\n          stack = [{ first: 0, last: len - 1 }]; // first processed edge\n\n          do {\n              ids = stack.shift();\n              if (ids.last <= ids.first + 1) // no intermediate points\n              {\n                  continue;\n              }\n\n              maxd = -1.0; // max distance from point to current edge\n              maxi = ids.first; // index of maximally distant point\n\n              for (i = ids.first + 1; i < ids.last; i++) // bypass intermediate points in edge\n              {\n                  // calc the distance from current point to edge\n                  pi = points[i];\n                  pf = points[ids.first];\n                  pl = points[ids.last];\n                  dx = pi.x - pf.x;\n                  dy = pi.y - pf.y;\n                  r1 = Math.sqrt(dx * dx + dy * dy);\n                  dx = pi.x - pl.x;\n                  dy = pi.y - pl.y;\n                  r2 = Math.sqrt(dx * dx + dy * dy);\n                  dx = pf.x - pl.x;\n                  dy = pf.y - pl.y;\n                  r12 = Math.sqrt(dx * dx + dy * dy);\n                  if (r1 >= Math.sqrt(r2 * r2 + r12 * r12)) dist = r2;\n                  else if (r2 >= Math.sqrt(r1 * r1 + r12 * r12)) dist = r1;\n                  else dist = Math.abs((dy * pi.x - dx * pi.y + pf.x * pl.y - pl.x * pf.y) / r12);\n\n                  if (dist > maxd) {\n                      maxi = i; // save the index of maximally distant point\n                      maxd = dist;\n                  }\n              }\n\n              if (maxd > simplifyTolerant) // if the max \"deviation\" is larger than allowed then...\n              {\n                  lst.push(maxi); // add index to the simplified list\n                  stack.push({ first: ids.first, last: maxi }); // add the left part for processing\n                  stack.push({ first: maxi, last: ids.last }); // add the right part for processing\n              }\n\n          } while (stack.length > 0);\n\n          resPoints = [];\n          len = lst.length;\n          lst.sort(function(a, b) { return a - b; }); // restore index order\n          for (k = 0; k < len; k++) {\n              resPoints.push({ x: points[lst[k]].x, y: points[lst[k]].y }); // add result points to the correct order\n          }\n          result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: c.points.length });\n      }\n\n      return result;\n  };\n\n  return lib;\n})();\n\nmodule.exports = MagicWand;\n//# sourceMappingURL=magic-wand.js.map\n"],"names":["MagicWand","lib","distance","x1","y1","x2","y2","dx","Math","abs","dy","sqrt","floodFill","image","px","py","extraX","extraY","colorThreshold","mask","includeBorders","radius","console","log","c","x","newY","el","xr","xl","dyl","dyr","checkY","data","w","width","h","height","bytes","maxX","minX","maxY","minY","i","result","Uint8Array","visited","allVisited","dpx","dpy","k","sampleColor","stack","push","y","left","right","dir","length","shift","bounds","floodFillWithBorders","floodFillWithoutBorders","backgroundFillWithBorders","gaussBlur","k1","val","end","n","s2","wg","Float32Array","total","dsq","ww","exp","PI","endX","endY","gaussBlurOnlyBorder","j","border","k2","visitedData","len","temp","x0","max","min","y0","createBorderForBlur","createBorderMask","rw","rh","offset","getBorderIndices","mainColor","newMarks","threshold","iterations","count","traceContours","inner","first","second","current","previous","next","d","m","prepareMask","contours","label","w2","src","dest","directions","points","simplifyContours","simplifyTolerant","simplifyCount","resPoints","lst","ids","maxd","maxi","dist","r1","r2","r12","pi","pf","pl","lenContours","initialCount","last","sort","a","b","module","exports"],"mappings":"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"}